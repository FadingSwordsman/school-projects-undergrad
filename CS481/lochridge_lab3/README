Solution for part 3:

	The algorithm which I used was marginal best movement:
		Each elevator takes the move that gives the best return of loading or leaving people per floor moved. To do this, each elevator scans through the list of floors, then through its list of passengers that leave for that floor. In plainer terms, the elevator calculates passengers that leave on floor n plus the number of people waiting on that floor, divides that by the number of floors it must move to get there, then selects the floor that has the largest number for that equation. With multiple elevators, a common array is updated that keeps track of each elevators' decision, adjusting later elevators' calculations using that floor.
		Essentially, this is a greedy algorithm, and should work well for cases in which a large number of people are moving to similar floors, and a good amount of time is available. Floors which rarely have passengers going to or from them are avoided, and don't cause the elevator to lose time for movement or opening and closing its doors. Transit time is considered, and the tendency will be for close elevators to go after larger floors nearby, limiting the loss in movement time.
		A possible improvement to this would be to have an array stored per elevator, reducing the complexity of each decision for the next floor to O(m+n), rather than O(n*m), where n is the number of floors, and m is the number of people on the given elevator. 
