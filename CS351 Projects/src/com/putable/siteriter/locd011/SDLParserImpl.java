package com.putable.siteriter.locd011;import java.io.IOException;import java.io.Reader;import java.io.StringReader;import java.util.HashMap;import java.util.LinkedList;import java.util.List;import java.util.Map;import java.util.Random;import com.putable.siteriter.SDLParseException;import com.putable.siteriter.SDLParser;public class SDLParserImpl implements SDLParser{    // Where we store our amortized Symbol table    private Map<String, Symbolable> definition = new HashMap<String, Symbolable>();    //private Map<String, Integer> selector = new HashMap<String, Integer>();    private String startString;    private boolean loaded = false;     @Override    public void load(Reader reader) throws IOException    {    	Iterable<Symbolable> symbols = LazyParser.parse(reader);    	    	Map<String, Symbolable> definition = new HashMap<String, Symbolable>();    	    	for(Symbolable symbol : symbols)    		definition.put(symbol.getName(), symbol);    	this.definition = definition;    	loaded = true;    	/*    		//Guarantee our reader supports all of the operations we need:	Reader loadedReader = copyOutReader(reader);	Iterable<Tuple<Token, String>> tokenStream = tokenize(loadedReader);	// Tokenizing complete	// Satisfy the assumptions of parsing:	startString = null;	Tuple<HashMap<String, Evaluable>, HashMap<String, Integer>> definitionSelectorPair = parse(tokenStream);	// Make sure our symbol tables are clear, just to be sure	//dropTables();	definition = definitionSelectorPair.getFirst();	selector = definitionSelectorPair.getSecond();	loaded = true;	// Parsing and loading complete	 * s	 */    }    @Override    public String makePage(String key, Map<String, Integer> selectors)    {	if(!loaded)	    throw new IllegalStateException();	// Don't call this without a start string...	if (!definition.containsKey(startString))	    return "";	//selector.putAll(selectors);	Random numberGen = new Random(key.hashCode());	String start = startString;	if (key.startsWith("/ss/"))	    start = alternateStartString(key);	String page = constructPage(numberGen, start, selectors);	//selector.clear();	return page;    }    /**     * Return the definition for the specified key     *      * @param key     * @return     */    public Symbolable getDefinition(String key)    {    	return definition.get(key);    }    /**     * Return the current selector for a given key during this generation     * attempt     *      * @param key     * @return     *//*    public int getSelector(String key)    {	if (selector.containsKey(key))	    return selector.get(key);	return -1;    }*/    /**     * Set the selector for a given selector key during this generation attempt     *      * @param key     * @param value     */    public void setSelector(String key, int value)    {	//selector.put(key, value);    }    private Iterable<Tuple<Token, String>> tokenize(Reader reader) throws IOException    {	List<Tuple<Token, String>> tokenList = new LinkedList<Tuple<Token, String>>();	boolean continuing = true;	while (continuing)	{	    // Take the first char of the next Token	    char nextChar = Utility.processChar(reader.read());	    if (!Character.isWhitespace(nextChar))	    {		Token nextToken = Token.getToken(nextChar);		// Let the Token handle its own rules, create a pair of the two		tokenList.add(new Tuple<Token, String>(nextToken, nextToken.getLexer().tokenize(nextChar, reader)));		continuing = nextToken != Token.EOI;	    }	}	tokenList.add(new Tuple<Token, String>(Token.EOI, ""));	return tokenList;    }        /**     * Copy out the reader, normalizing everything. This is to prevent problems like ridiculous codepoint numbers for the future.     * @param unknownReader     * @return     * @throws IOException     */    private Reader copyOutReader(Reader unknownReader) throws IOException    {	String readerInput = "";	int nextCodePoint = unknownReader.read();	while(nextCodePoint != -1)	{	    char nextChar = (char)nextCodePoint; 	    readerInput += nextChar;	    nextCodePoint = unknownReader.read();	}	return new StringReader(readerInput);    }    /**     *      * Parses our list of tokens, to see if they're valid, and returns the     * Symbol table     *      * @param tokenValuePairs     *      * @return     *      * @throws SDLParseException     */    private Tuple<HashMap<String, Evaluable>, HashMap<String, Integer>> parse(Iterable<Tuple<Token, String>> tokenValuePairs) throws SDLParseException    {	HashMap<String, Evaluable> tokenDefinition = new HashMap<String, Evaluable>();	HashMap<String, Integer> selectorDefinition = new HashMap<String, Integer>();	Iterable<Evaluable> ruleList = ParseConstruction.beginParse(tokenValuePairs, this);	for (Evaluable rule : ruleList)	{	    Symbol ruleSymbol = rule.getSymbol();	    if (startString == null)		startString = ruleSymbol.getName();	    tokenDefinition.put(ruleSymbol.getName(), rule);	}	return new Tuple<HashMap<String, Evaluable>, HashMap<String, Integer>>(tokenDefinition, selectorDefinition);    }    private String alternateStartString(String key)    {	String toReturn = startString;	if (key.startsWith("/ss/"))	{	    String toFind = key.substring(4, key.length());	    int toRemoveAfter = toFind.indexOf('/');	    if (toRemoveAfter >= 0)	    {		toFind = toFind.substring(0, toRemoveAfter);		if (definition.containsKey(toFind))		    if (definition.get(toFind).isAlternateStart())			toReturn = toFind;	    }	}	return toReturn;    }    private String constructPage(Random numberGen, String startSymbol, Map<String, Integer> selectors)    {	Symbolable toEval = definition.get(startSymbol);	String page = toEval.evaluate(numberGen,  definition, selectors);	return page;    }}