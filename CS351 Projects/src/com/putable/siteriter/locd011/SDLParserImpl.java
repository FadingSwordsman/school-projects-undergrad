package com.putable.siteriter.locd011;import java.io.IOException;import java.io.Reader;import java.util.HashMap;import java.util.Map;import java.util.Random;import com.putable.siteriter.SDLParser;public class SDLParserImpl implements SDLParser{    // Where we store our amortized Symbol table    private Map<String, Symbol> definition = new HashMap<String, Symbol>();    private String startString;    private boolean loaded = false;     @Override    public void load(Reader reader) throws IOException    {    	Iterable<Symbol> symbols = LazyParser.parse(reader);    	    	Map<String, Symbol> definition = new HashMap<String, Symbol>();    	    	loaded = false;    	startString = null;    	for(Symbol symbol : symbols)    	{    		if(startString == null)    			startString = symbol.getName();    		definition.put(symbol.getName(), symbol);    	}    	this.definition = definition;    	loaded = true;    }    @Override    public String makePage(String key, Map<String, Integer> selectors)    {	if(key == null || selectors == null)	    throw new NullPointerException("Null argument!");	if(!loaded)	    throw new IllegalStateException();	// Don't call this without a start string...	String start = startString;	if (key.startsWith("/ss/"))	    start = alternateStartString(key);	if(start == null)		return null;	if (!definition.containsKey(start))	    return "";	//Avoid modifying the HashMap given to us by the server (i.e. avoid ConcurrentModificationExceptions!)	//Removing this will cause two tests to fail with The aforementioned exception.	Map<String, Integer> selector = new HashMap<String, Integer>();	selector.putAll(selectors);	Random numberGen = new Random(key.hashCode());	String page = constructPage(numberGen, start, selector);	return page;    }            /**     * Determine whether the key is a valid alternate start string     * @param key     * @return Which key is the valid start string     */    private String alternateStartString(String key)    {	String toReturn = startString;	if (key.startsWith("/ss/"))	{	    String toFind = key.substring(4, key.length());	    int toRemoveAfter = toFind.indexOf('/');	    if (toRemoveAfter >= 0)	    {		toFind = toFind.substring(0, toRemoveAfter);		if (definition.containsKey(toFind))		    if (definition.get(toFind).isAlternateStart())			toReturn = toFind;	    }	}	return toReturn;    }    /**     * A helper to pass our definitions and selectors into the generator     * @param numberGen     * @param startSymbol     * @param selectors     * @return     */    private String constructPage(Random numberGen, String startSymbol, Map<String, Integer> selectors)    {	Symbol toEval = definition.get(startSymbol);	return toEval.evaluate(numberGen,  definition, selectors);    }}